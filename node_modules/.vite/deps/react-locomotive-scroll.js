import {
  require_jsx_runtime
} from "./chunk-VLDDMMPX.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-TL73C5TT.js";

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/use-debounce/lib/useDebouncedCallback.js
var require_useDebouncedCallback = __commonJS({
  "node_modules/use-debounce/lib/useDebouncedCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    function useDebouncedCallback(func, wait, options) {
      var _this = this;
      var lastCallTime = react_1.useRef(null);
      var lastInvokeTime = react_1.useRef(0);
      var timerId = react_1.useRef(null);
      var lastArgs = react_1.useRef([]);
      var lastThis = react_1.useRef();
      var result = react_1.useRef();
      var funcRef = react_1.useRef(func);
      var mounted = react_1.useRef(true);
      funcRef.current = func;
      var useRAF = !wait && wait !== 0 && typeof window !== "undefined";
      if (typeof func !== "function") {
        throw new TypeError("Expected a function");
      }
      wait = +wait || 0;
      options = options || {};
      var leading = !!options.leading;
      var trailing = "trailing" in options ? !!options.trailing : true;
      var maxing = "maxWait" in options;
      var maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;
      react_1.useEffect(function() {
        mounted.current = true;
        return function() {
          mounted.current = false;
        };
      }, []);
      var debounced = react_1.useMemo(function() {
        var invokeFunc = function(time) {
          var args = lastArgs.current;
          var thisArg = lastThis.current;
          lastArgs.current = lastThis.current = null;
          lastInvokeTime.current = time;
          return result.current = funcRef.current.apply(thisArg, args);
        };
        var startTimer = function(pendingFunc, wait2) {
          if (useRAF)
            cancelAnimationFrame(timerId.current);
          timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait2);
        };
        var shouldInvoke = function(time) {
          if (!mounted.current)
            return false;
          var timeSinceLastCall = time - lastCallTime.current;
          var timeSinceLastInvoke = time - lastInvokeTime.current;
          return !lastCallTime.current || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        };
        var trailingEdge = function(time) {
          timerId.current = null;
          if (trailing && lastArgs.current) {
            return invokeFunc(time);
          }
          lastArgs.current = lastThis.current = null;
          return result.current;
        };
        var timerExpired = function() {
          var time = Date.now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          if (!mounted.current) {
            return;
          }
          var timeSinceLastCall = time - lastCallTime.current;
          var timeSinceLastInvoke = time - lastInvokeTime.current;
          var timeWaiting = wait - timeSinceLastCall;
          var remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          startTimer(timerExpired, remainingWait);
        };
        var func2 = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var time = Date.now();
          var isInvoking = shouldInvoke(time);
          lastArgs.current = args;
          lastThis.current = _this;
          lastCallTime.current = time;
          if (isInvoking) {
            if (!timerId.current && mounted.current) {
              lastInvokeTime.current = lastCallTime.current;
              startTimer(timerExpired, wait);
              return leading ? invokeFunc(lastCallTime.current) : result.current;
            }
            if (maxing) {
              startTimer(timerExpired, wait);
              return invokeFunc(lastCallTime.current);
            }
          }
          if (!timerId.current) {
            startTimer(timerExpired, wait);
          }
          return result.current;
        };
        func2.cancel = function() {
          if (timerId.current) {
            useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);
          }
          lastInvokeTime.current = 0;
          lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;
        };
        func2.isPending = function() {
          return !!timerId.current;
        };
        func2.flush = function() {
          return !timerId.current ? result.current : trailingEdge(Date.now());
        };
        return func2;
      }, [leading, maxing, wait, maxWait, trailing, useRAF]);
      return debounced;
    }
    exports.default = useDebouncedCallback;
  }
});

// node_modules/use-debounce/lib/useDebounce.js
var require_useDebounce = __commonJS({
  "node_modules/use-debounce/lib/useDebounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var useDebouncedCallback_1 = require_useDebouncedCallback();
    function valueEquality(left, right) {
      return left === right;
    }
    function adjustFunctionValueOfSetState(value) {
      return typeof value === "function" ? function() {
        return value;
      } : value;
    }
    function useStateIgnoreCallback(initialState) {
      var _a = react_1.useState(adjustFunctionValueOfSetState(initialState)), state = _a[0], setState = _a[1];
      var setStateIgnoreCallback = react_1.useCallback(function(value) {
        return setState(adjustFunctionValueOfSetState(value));
      }, []);
      return [state, setStateIgnoreCallback];
    }
    function useDebounce(value, delay, options) {
      var eq = options && options.equalityFn || valueEquality;
      var _a = useStateIgnoreCallback(value), state = _a[0], dispatch = _a[1];
      var debounced = useDebouncedCallback_1.default(react_1.useCallback(function(value2) {
        return dispatch(value2);
      }, [dispatch]), delay, options);
      var previousValue = react_1.useRef(value);
      react_1.useEffect(function() {
        if (!eq(previousValue.current, value)) {
          debounced(value);
          previousValue.current = value;
        }
      }, [value, debounced, eq]);
      return [state, { cancel: debounced.cancel, isPending: debounced.isPending, flush: debounced.flush }];
    }
    exports.default = useDebounce;
  }
});

// node_modules/use-debounce/lib/useThrottledCallback.js
var require_useThrottledCallback = __commonJS({
  "node_modules/use-debounce/lib/useThrottledCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var useDebouncedCallback_1 = require_useDebouncedCallback();
    function useThrottledCallback(func, wait, _a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.leading, leading = _c === void 0 ? true : _c, _d = _b.trailing, trailing = _d === void 0 ? true : _d;
      return useDebouncedCallback_1.default(func, wait, {
        maxWait: wait,
        leading,
        trailing
      });
    }
    exports.default = useThrottledCallback;
  }
});

// node_modules/use-debounce/lib/index.js
var require_lib = __commonJS({
  "node_modules/use-debounce/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var useDebounce_1 = require_useDebounce();
    exports.useDebounce = useDebounce_1.default;
    var useDebouncedCallback_1 = require_useDebouncedCallback();
    exports.useDebouncedCallback = useDebouncedCallback_1.default;
    var useThrottledCallback_1 = require_useThrottledCallback();
    exports.useThrottledCallback = useThrottledCallback_1.default;
  }
});

// node_modules/use-resize-observer/dist/bundle.esm.js
var bundle_esm_exports = {};
__export(bundle_esm_exports, {
  default: () => bundle_esm_default
});
function useResizeObserver(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var defaultRef = (0, import_react.useRef)(null);
  var onResize = opts.onResize;
  var onResizeRef = (0, import_react.useRef)(void 0);
  onResizeRef.current = onResize;
  var resizeObserverRef = (0, import_react.useRef)();
  var ref = opts.ref || defaultRef;
  var _useState = (0, import_react.useState)({
    width: void 0,
    height: void 0
  }), size = _useState[0], setSize = _useState[1];
  var previous = (0, import_react.useRef)({
    width: void 0,
    height: void 0
  });
  (0, import_react.useEffect)(function() {
    if (resizeObserverRef.current) {
      return;
    }
    resizeObserverRef.current = new ResizeObserver(function(entries) {
      if (!Array.isArray(entries)) {
        return;
      }
      if (!entries.length) {
        return;
      }
      var entry = entries[0];
      var newWidth = Math.round(entry.contentRect.width);
      var newHeight = Math.round(entry.contentRect.height);
      if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
        var newSize = {
          width: newWidth,
          height: newHeight
        };
        if (onResizeRef.current) {
          onResizeRef.current(newSize);
        } else {
          previous.current.width = newWidth;
          previous.current.height = newHeight;
          setSize(newSize);
        }
      }
    });
  }, []);
  (0, import_react.useEffect)(function() {
    if (typeof ref !== "object" || ref === null || !(ref.current instanceof Element)) {
      return;
    }
    var element = ref.current;
    resizeObserverRef.current.observe(element);
    return function() {
      return resizeObserverRef.current.unobserve(element);
    };
  }, [ref]);
  return (0, import_react.useMemo)(function() {
    return {
      ref,
      width: size.width,
      height: size.height
    };
  }, [ref, size ? size.width : null, size ? size.height : null]);
}
var import_react, bundle_esm_default;
var init_bundle_esm = __esm({
  "node_modules/use-resize-observer/dist/bundle.esm.js"() {
    import_react = __toESM(require_react());
    bundle_esm_default = useResizeObserver;
  }
});

// node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js
var locomotive_scroll_esm_exports = {};
__export(locomotive_scroll_esm_exports, {
  Native: () => Native,
  Smooth: () => Smooth,
  default: () => locomotive_scroll_esm_default
});
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function E() {
}
function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}
function VirtualScroll(options) {
  bindallStandalone(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown");
  this.el = window;
  if (options && options.el) {
    this.el = options.el;
    delete options.el;
  }
  this.options = objectAssign({
    mouseMultiplier: 1,
    touchMultiplier: 2,
    firefoxMultiplier: 15,
    keyStep: 120,
    preventTouch: false,
    unpreventTouchClass: "vs-touchmove-allowed",
    limitInertia: false,
    useKeyboard: true,
    useTouch: true
  }, options);
  if (this.options.limitInertia)
    this._lethargy = new Lethargy();
  this._emitter = new tinyEmitter();
  this._event = {
    y: 0,
    x: 0,
    deltaX: 0,
    deltaY: 0
  };
  this.touchStartX = null;
  this.touchStartY = null;
  this.bodyTouchAction = null;
  if (this.options.passive !== void 0) {
    this.listenerOptions = { passive: this.options.passive };
  }
}
function lerp(start, end, amt) {
  return (1 - amt) * start + amt * end;
}
function getTranslate(el) {
  var translate = {};
  if (!window.getComputedStyle)
    return;
  var style = getComputedStyle(el);
  var transform = style.transform || style.webkitTransform || style.mozTransform;
  var mat = transform.match(/^matrix3d\((.+)\)$/);
  if (mat) {
    translate.x = mat ? parseFloat(mat[1].split(", ")[12]) : 0;
    translate.y = mat ? parseFloat(mat[1].split(", ")[13]) : 0;
  } else {
    mat = transform.match(/^matrix\((.+)\)$/);
    translate.x = mat ? parseFloat(mat[1].split(", ")[4]) : 0;
    translate.y = mat ? parseFloat(mat[1].split(", ")[5]) : 0;
  }
  return translate;
}
function getParents(elem) {
  var parents = [];
  for (; elem && elem !== document; elem = elem.parentNode) {
    parents.push(elem);
  }
  return parents;
}
function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function LinearEasing(x) {
  return x;
}
var defaults, _default, commonjsGlobal, smoothscroll, smoothscroll_1, _default$1, getOwnPropertySymbols, hasOwnProperty, propIsEnumerable, objectAssign, tinyEmitter, lethargy, support, toString, hasOwnProperty$1, bindallStandalone, Lethargy, EVT_ID, src, keyCodes, NEWTON_ITERATIONS, NEWTON_MIN_SLOPE, SUBDIVISION_PRECISION, SUBDIVISION_MAX_ITERATIONS, kSplineTableSize, kSampleStepSize, float32ArraySupported, src$1, keyCodes$1, _default$2, Smooth, Native, locomotive_scroll_esm_default;
var init_locomotive_scroll_esm = __esm({
  "node_modules/locomotive-scroll/dist/locomotive-scroll.esm.js"() {
    defaults = {
      el: document,
      name: "scroll",
      offset: [0, 0],
      repeat: false,
      smooth: false,
      initPosition: {
        x: 0,
        y: 0
      },
      direction: "vertical",
      gestureDirection: "vertical",
      reloadOnContextChange: false,
      lerp: 0.1,
      "class": "is-inview",
      scrollbarContainer: false,
      scrollbarClass: "c-scrollbar",
      scrollingClass: "has-scroll-scrolling",
      draggingClass: "has-scroll-dragging",
      smoothClass: "has-scroll-smooth",
      initClass: "has-scroll-init",
      getSpeed: false,
      getDirection: false,
      scrollFromAnywhere: false,
      multiplier: 1,
      firefoxMultiplier: 50,
      touchMultiplier: 2,
      resetNativeScroll: true,
      tablet: {
        smooth: false,
        direction: "vertical",
        gestureDirection: "vertical",
        breakpoint: 1024
      },
      smartphone: {
        smooth: false,
        direction: "vertical",
        gestureDirection: "vertical"
      }
    };
    _default = function() {
      function _default2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, _default2);
        Object.assign(this, defaults, options);
        this.smartphone = defaults.smartphone;
        if (options.smartphone)
          Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults.tablet;
        if (options.tablet)
          Object.assign(this.tablet, options.tablet);
        this.namespace = "locomotive";
        this.html = document.documentElement;
        this.windowHeight = window.innerHeight;
        this.windowWidth = window.innerWidth;
        this.windowMiddle = {
          x: this.windowWidth / 2,
          y: this.windowHeight / 2
        };
        this.els = {};
        this.currentElements = {};
        this.listeners = {};
        this.hasScrollTicking = false;
        this.hasCallEventSet = false;
        this.checkScroll = this.checkScroll.bind(this);
        this.checkResize = this.checkResize.bind(this);
        this.checkEvent = this.checkEvent.bind(this);
        this.instance = {
          scroll: {
            x: 0,
            y: 0
          },
          limit: {
            x: this.html.offsetWidth,
            y: this.html.offsetHeight
          },
          currentElements: this.currentElements
        };
        if (this.isMobile) {
          if (this.isTablet) {
            this.context = "tablet";
          } else {
            this.context = "smartphone";
          }
        } else {
          this.context = "desktop";
        }
        if (this.isMobile)
          this.direction = this[this.context].direction;
        if (this.direction === "horizontal") {
          this.directionAxis = "x";
        } else {
          this.directionAxis = "y";
        }
        if (this.getDirection) {
          this.instance.direction = null;
        }
        if (this.getDirection) {
          this.instance.speed = 0;
        }
        this.html.classList.add(this.initClass);
        window.addEventListener("resize", this.checkResize, false);
      }
      _createClass(_default2, [{
        key: "init",
        value: function init() {
          this.initEvents();
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          this.dispatchScroll();
        }
      }, {
        key: "checkResize",
        value: function checkResize() {
          var _this = this;
          if (!this.resizeTick) {
            this.resizeTick = true;
            requestAnimationFrame(function() {
              _this.resize();
              _this.resizeTick = false;
            });
          }
        }
      }, {
        key: "resize",
        value: function resize() {
        }
      }, {
        key: "checkContext",
        value: function checkContext() {
          if (!this.reloadOnContextChange)
            return;
          this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint;
          this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
          var oldContext = this.context;
          if (this.isMobile) {
            if (this.isTablet) {
              this.context = "tablet";
            } else {
              this.context = "smartphone";
            }
          } else {
            this.context = "desktop";
          }
          if (oldContext != this.context) {
            var oldSmooth = oldContext == "desktop" ? this.smooth : this[oldContext].smooth;
            var newSmooth = this.context == "desktop" ? this.smooth : this[this.context].smooth;
            if (oldSmooth != newSmooth)
              window.location.reload();
          }
        }
      }, {
        key: "initEvents",
        value: function initEvents() {
          var _this2 = this;
          this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]"));
          this.setScrollTo = this.setScrollTo.bind(this);
          this.scrollToEls.forEach(function(el) {
            el.addEventListener("click", _this2.setScrollTo, false);
          });
        }
      }, {
        key: "setScrollTo",
        value: function setScrollTo(event) {
          event.preventDefault();
          this.scrollTo(event.currentTarget.getAttribute("data-".concat(this.name, "-href")) || event.currentTarget.getAttribute("href"), {
            offset: event.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
          });
        }
      }, {
        key: "addElements",
        value: function addElements() {
        }
      }, {
        key: "detectElements",
        value: function detectElements(hasCallEventSet) {
          var _this3 = this;
          var scrollTop = this.instance.scroll.y;
          var scrollBottom = scrollTop + this.windowHeight;
          var scrollLeft = this.instance.scroll.x;
          var scrollRight = scrollLeft + this.windowWidth;
          Object.entries(this.els).forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];
            if (el && (!el.inView || hasCallEventSet)) {
              if (_this3.direction === "horizontal") {
                if (scrollRight >= el.left && scrollLeft < el.right) {
                  _this3.setInView(el, i);
                }
              } else {
                if (scrollBottom >= el.top && scrollTop < el.bottom) {
                  _this3.setInView(el, i);
                }
              }
            }
            if (el && el.inView) {
              if (_this3.direction === "horizontal") {
                var width = el.right - el.left;
                el.progress = (_this3.instance.scroll.x - (el.left - _this3.windowWidth)) / (width + _this3.windowWidth);
                if (scrollRight < el.left || scrollLeft > el.right) {
                  _this3.setOutOfView(el, i);
                }
              } else {
                var height = el.bottom - el.top;
                el.progress = (_this3.instance.scroll.y - (el.top - _this3.windowHeight)) / (height + _this3.windowHeight);
                if (scrollBottom < el.top || scrollTop > el.bottom) {
                  _this3.setOutOfView(el, i);
                }
              }
            }
          });
          this.hasScrollTicking = false;
        }
      }, {
        key: "setInView",
        value: function setInView(current, i) {
          this.els[i].inView = true;
          current.el.classList.add(current["class"]);
          this.currentElements[i] = current;
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, "enter");
            if (!current.repeat) {
              this.els[i].call = false;
            }
          }
        }
      }, {
        key: "setOutOfView",
        value: function setOutOfView(current, i) {
          var _this4 = this;
          this.els[i].inView = false;
          Object.keys(this.currentElements).forEach(function(el) {
            el === i && delete _this4.currentElements[el];
          });
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, "exit");
          }
          if (current.repeat) {
            current.el.classList.remove(current["class"]);
          }
        }
      }, {
        key: "dispatchCall",
        value: function dispatchCall(current, way) {
          this.callWay = way;
          this.callValue = current.call.split(",").map(function(item) {
            return item.trim();
          });
          this.callObj = current;
          if (this.callValue.length == 1)
            this.callValue = this.callValue[0];
          var callEvent = new Event(this.namespace + "call");
          this.el.dispatchEvent(callEvent);
        }
      }, {
        key: "dispatchScroll",
        value: function dispatchScroll() {
          var scrollEvent = new Event(this.namespace + "scroll");
          this.el.dispatchEvent(scrollEvent);
        }
      }, {
        key: "setEvents",
        value: function setEvents(event, func) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          var list = this.listeners[event];
          list.push(func);
          if (list.length === 1) {
            this.el.addEventListener(this.namespace + event, this.checkEvent, false);
          }
          if (event === "call") {
            this.hasCallEventSet = true;
            this.detectElements(true);
          }
        }
      }, {
        key: "unsetEvents",
        value: function unsetEvents(event, func) {
          if (!this.listeners[event])
            return;
          var list = this.listeners[event];
          var index = list.indexOf(func);
          if (index < 0)
            return;
          list.splice(index, 1);
          if (list.index === 0) {
            this.el.removeEventListener(this.namespace + event, this.checkEvent, false);
          }
        }
      }, {
        key: "checkEvent",
        value: function checkEvent(event) {
          var _this5 = this;
          var name = event.type.replace(this.namespace, "");
          var list = this.listeners[name];
          if (!list || list.length === 0)
            return;
          list.forEach(function(func) {
            switch (name) {
              case "scroll":
                return func(_this5.instance);
              case "call":
                return func(_this5.callValue, _this5.callWay, _this5.callObj);
              default:
                return func();
            }
          });
        }
      }, {
        key: "startScroll",
        value: function startScroll() {
        }
      }, {
        key: "stopScroll",
        value: function stopScroll() {
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance.scroll = {
            x: 0,
            y: 0
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this6 = this;
          window.removeEventListener("resize", this.checkResize, false);
          Object.keys(this.listeners).forEach(function(event) {
            _this6.el.removeEventListener(_this6.namespace + event, _this6.checkEvent, false);
          });
          this.listeners = {};
          this.scrollToEls.forEach(function(el) {
            el.removeEventListener("click", _this6.setScrollTo, false);
          });
          this.html.classList.remove(this.initClass);
        }
      }]);
      return _default2;
    }();
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    smoothscroll = createCommonjsModule(function(module, exports) {
      (function() {
        function polyfill() {
          var w = window;
          var d = document;
          if ("scrollBehavior" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {
            return;
          }
          var Element2 = w.HTMLElement || w.Element;
          var SCROLL_TIME = 468;
          var original = {
            scroll: w.scroll || w.scrollTo,
            scrollBy: w.scrollBy,
            elementScroll: Element2.prototype.scroll || scrollElement,
            scrollIntoView: Element2.prototype.scrollIntoView
          };
          var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;
          function isMicrosoftBrowser(userAgent) {
            var userAgentPatterns = ["MSIE ", "Trident/", "Edge/"];
            return new RegExp(userAgentPatterns.join("|")).test(userAgent);
          }
          var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;
          function scrollElement(x, y) {
            this.scrollLeft = x;
            this.scrollTop = y;
          }
          function ease(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
          }
          function shouldBailOut(firstArg) {
            if (firstArg === null || typeof firstArg !== "object" || firstArg.behavior === void 0 || firstArg.behavior === "auto" || firstArg.behavior === "instant") {
              return true;
            }
            if (typeof firstArg === "object" && firstArg.behavior === "smooth") {
              return false;
            }
            throw new TypeError(
              "behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior."
            );
          }
          function hasScrollableSpace(el, axis) {
            if (axis === "Y") {
              return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
            }
            if (axis === "X") {
              return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
            }
          }
          function canOverflow(el, axis) {
            var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];
            return overflowValue === "auto" || overflowValue === "scroll";
          }
          function isScrollable(el) {
            var isScrollableY = hasScrollableSpace(el, "Y") && canOverflow(el, "Y");
            var isScrollableX = hasScrollableSpace(el, "X") && canOverflow(el, "X");
            return isScrollableY || isScrollableX;
          }
          function findScrollableParent(el) {
            while (el !== d.body && isScrollable(el) === false) {
              el = el.parentNode || el.host;
            }
            return el;
          }
          function step(context) {
            var time = now();
            var value;
            var currentX;
            var currentY;
            var elapsed = (time - context.startTime) / SCROLL_TIME;
            elapsed = elapsed > 1 ? 1 : elapsed;
            value = ease(elapsed);
            currentX = context.startX + (context.x - context.startX) * value;
            currentY = context.startY + (context.y - context.startY) * value;
            context.method.call(context.scrollable, currentX, currentY);
            if (currentX !== context.x || currentY !== context.y) {
              w.requestAnimationFrame(step.bind(w, context));
            }
          }
          function smoothScroll(el, x, y) {
            var scrollable;
            var startX;
            var startY;
            var method;
            var startTime = now();
            if (el === d.body) {
              scrollable = w;
              startX = w.scrollX || w.pageXOffset;
              startY = w.scrollY || w.pageYOffset;
              method = original.scroll;
            } else {
              scrollable = el;
              startX = el.scrollLeft;
              startY = el.scrollTop;
              method = scrollElement;
            }
            step({
              scrollable,
              method,
              startTime,
              startX,
              startY,
              x,
              y
            });
          }
          w.scroll = w.scrollTo = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              original.scroll.call(
                w,
                arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : w.scrollX || w.pageXOffset,
                arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset
              );
              return;
            }
            smoothScroll.call(
              w,
              d.body,
              arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,
              arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset
            );
          };
          w.scrollBy = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0])) {
              original.scrollBy.call(
                w,
                arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : 0,
                arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0
              );
              return;
            }
            smoothScroll.call(
              w,
              d.body,
              ~~arguments[0].left + (w.scrollX || w.pageXOffset),
              ~~arguments[0].top + (w.scrollY || w.pageYOffset)
            );
          };
          Element2.prototype.scroll = Element2.prototype.scrollTo = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              if (typeof arguments[0] === "number" && arguments[1] === void 0) {
                throw new SyntaxError("Value could not be converted");
              }
              original.elementScroll.call(
                this,
                arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== "object" ? ~~arguments[0] : this.scrollLeft,
                arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop
              );
              return;
            }
            var left = arguments[0].left;
            var top = arguments[0].top;
            smoothScroll.call(
              this,
              this,
              typeof left === "undefined" ? this.scrollLeft : ~~left,
              typeof top === "undefined" ? this.scrollTop : ~~top
            );
          };
          Element2.prototype.scrollBy = function() {
            if (arguments[0] === void 0) {
              return;
            }
            if (shouldBailOut(arguments[0]) === true) {
              original.elementScroll.call(
                this,
                arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,
                arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop
              );
              return;
            }
            this.scroll({
              left: ~~arguments[0].left + this.scrollLeft,
              top: ~~arguments[0].top + this.scrollTop,
              behavior: arguments[0].behavior
            });
          };
          Element2.prototype.scrollIntoView = function() {
            if (shouldBailOut(arguments[0]) === true) {
              original.scrollIntoView.call(
                this,
                arguments[0] === void 0 ? true : arguments[0]
              );
              return;
            }
            var scrollableParent = findScrollableParent(this);
            var parentRects = scrollableParent.getBoundingClientRect();
            var clientRects = this.getBoundingClientRect();
            if (scrollableParent !== d.body) {
              smoothScroll.call(
                this,
                scrollableParent,
                scrollableParent.scrollLeft + clientRects.left - parentRects.left,
                scrollableParent.scrollTop + clientRects.top - parentRects.top
              );
              if (w.getComputedStyle(scrollableParent).position !== "fixed") {
                w.scrollBy({
                  left: parentRects.left,
                  top: parentRects.top,
                  behavior: "smooth"
                });
              }
            } else {
              w.scrollBy({
                left: clientRects.left,
                top: clientRects.top,
                behavior: "smooth"
              });
            }
          };
        }
        {
          module.exports = { polyfill };
        }
      })();
    });
    smoothscroll_1 = smoothscroll.polyfill;
    _default$1 = function(_Core) {
      _inherits(_default2, _Core);
      var _super = _createSuper(_default2);
      function _default2() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, _default2);
        _this = _super.call(this, options);
        if (_this.resetNativeScroll) {
          if (history.scrollRestoration) {
            history.scrollRestoration = "manual";
          }
          window.scrollTo(0, 0);
        }
        window.addEventListener("scroll", _this.checkScroll, false);
        if (window.smoothscrollPolyfill === void 0) {
          window.smoothscrollPolyfill = smoothscroll;
          window.smoothscrollPolyfill.polyfill();
        }
        return _this;
      }
      _createClass(_default2, [{
        key: "init",
        value: function init() {
          this.instance.scroll.y = window.pageYOffset;
          this.addElements();
          this.detectElements();
          _get(_getPrototypeOf(_default2.prototype), "init", this).call(this);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this2 = this;
          _get(_getPrototypeOf(_default2.prototype), "checkScroll", this).call(this);
          if (this.getDirection) {
            this.addDirection();
          }
          if (this.getSpeed) {
            this.addSpeed();
            this.speedTs = Date.now();
          }
          this.instance.scroll.y = window.pageYOffset;
          if (Object.entries(this.els).length) {
            if (!this.hasScrollTicking) {
              requestAnimationFrame(function() {
                _this2.detectElements();
              });
              this.hasScrollTicking = true;
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (window.pageYOffset > this.instance.scroll.y) {
            if (this.instance.direction !== "down") {
              this.instance.direction = "down";
            }
          } else if (window.pageYOffset < this.instance.scroll.y) {
            if (this.instance.direction !== "up") {
              this.instance.direction = "up";
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (window.pageYOffset != this.instance.scroll.y) {
            this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "resize",
        value: function resize() {
          if (Object.entries(this.els).length) {
            this.windowHeight = window.innerHeight;
            this.updateElements();
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this3 = this;
          this.els = {};
          var els = this.el.querySelectorAll("[data-" + this.name + "]");
          els.forEach(function(el, index) {
            var BCR = el.getBoundingClientRect();
            var cl = el.dataset[_this3.name + "Class"] || _this3["class"];
            var id = typeof el.dataset[_this3.name + "Id"] === "string" ? el.dataset[_this3.name + "Id"] : index;
            var top;
            var left;
            var offset = typeof el.dataset[_this3.name + "Offset"] === "string" ? el.dataset[_this3.name + "Offset"].split(",") : _this3.offset;
            var repeat = el.dataset[_this3.name + "Repeat"];
            var call = el.dataset[_this3.name + "Call"];
            var target = el.dataset[_this3.name + "Target"];
            var targetEl;
            if (target !== void 0) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            top = targetElBCR.top + _this3.instance.scroll.y;
            left = targetElBCR.left + _this3.instance.scroll.x;
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            if (repeat == "false") {
              repeat = false;
            } else if (repeat != void 0) {
              repeat = true;
            } else {
              repeat = _this3.repeat;
            }
            var relativeOffset = _this3.getRelativeOffset(offset);
            top = top + relativeOffset[0];
            bottom = bottom - relativeOffset[1];
            var mappedEl = {
              el,
              targetEl,
              id,
              "class": cl,
              top,
              bottom,
              left,
              right,
              offset,
              progress: 0,
              repeat,
              inView: false,
              call
            };
            _this3.els[id] = mappedEl;
            if (el.classList.contains(cl)) {
              _this3.setInView(_this3.els[id], id);
            }
          });
        }
      }, {
        key: "updateElements",
        value: function updateElements() {
          var _this4 = this;
          Object.entries(this.els).forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], el = _ref2[1];
            var top = el.targetEl.getBoundingClientRect().top + _this4.instance.scroll.y;
            var bottom = top + el.targetEl.offsetHeight;
            var relativeOffset = _this4.getRelativeOffset(el.offset);
            _this4.els[i].top = top + relativeOffset[0];
            _this4.els[i].bottom = bottom - relativeOffset[1];
          });
          this.hasScrollTicking = false;
        }
      }, {
        key: "getRelativeOffset",
        value: function getRelativeOffset(offset) {
          var relativeOffset = [0, 0];
          if (offset) {
            for (var i = 0; i < offset.length; i++) {
              if (typeof offset[i] == "string") {
                if (offset[i].includes("%")) {
                  relativeOffset[i] = parseInt(offset[i].replace("%", "") * this.windowHeight / 100);
                } else {
                  relativeOffset[i] = parseInt(offset[i]);
                }
              } else {
                relativeOffset[i] = offset[i];
              }
            }
          }
          return relativeOffset;
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var offset = parseInt(options.offset) || 0;
          var callback = options.callback ? options.callback : false;
          if (typeof target === "string") {
            if (target === "top") {
              target = this.html;
            } else if (target === "bottom") {
              target = this.html.offsetHeight - window.innerHeight;
            } else {
              target = document.querySelector(target);
              if (!target) {
                return;
              }
            }
          } else if (typeof target === "number") {
            target = parseInt(target);
          } else if (target && target.tagName)
            ;
          else {
            console.warn("`target` parameter is not valid");
            return;
          }
          if (typeof target !== "number") {
            offset = target.getBoundingClientRect().top + offset + this.instance.scroll.y;
          } else {
            offset = target + offset;
          }
          var isTargetReached = function isTargetReached2() {
            return parseInt(window.pageYOffset) === parseInt(offset);
          };
          if (callback) {
            if (isTargetReached()) {
              callback();
              return;
            } else {
              var onScroll = function onScroll2() {
                if (isTargetReached()) {
                  window.removeEventListener("scroll", onScroll2);
                  callback();
                }
              };
              window.addEventListener("scroll", onScroll);
            }
          }
          window.scrollTo({
            top: offset,
            behavior: options.duration === 0 ? "auto" : "smooth"
          });
        }
      }, {
        key: "update",
        value: function update() {
          this.addElements();
          this.detectElements();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(_default2.prototype), "destroy", this).call(this);
          window.removeEventListener("scroll", this.checkScroll, false);
        }
      }]);
      return _default2;
    }(_default);
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    propIsEnumerable = Object.prototype.propertyIsEnumerable;
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self2 = this;
        function listener() {
          self2.off(name, listener);
          callback.apply(ctx, arguments);
        }
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    tinyEmitter = E;
    lethargy = createCommonjsModule(function(module, exports) {
      (function() {
        var root;
        root = exports !== null ? exports : this;
        root.Lethargy = function() {
          function Lethargy2(stability, sensitivity, tolerance, delay) {
            this.stability = stability != null ? Math.abs(stability) : 8;
            this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
            this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
            this.delay = delay != null ? delay : 150;
            this.lastUpDeltas = function() {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.lastDownDeltas = function() {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.deltasTimestamp = function() {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
          }
          Lethargy2.prototype.check = function(e) {
            var lastDelta;
            e = e.originalEvent || e;
            if (e.wheelDelta != null) {
              lastDelta = e.wheelDelta;
            } else if (e.deltaY != null) {
              lastDelta = e.deltaY * -40;
            } else if (e.detail != null || e.detail === 0) {
              lastDelta = e.detail * -40;
            }
            this.deltasTimestamp.push(Date.now());
            this.deltasTimestamp.shift();
            if (lastDelta > 0) {
              this.lastUpDeltas.push(lastDelta);
              this.lastUpDeltas.shift();
              return this.isInertia(1);
            } else {
              this.lastDownDeltas.push(lastDelta);
              this.lastDownDeltas.shift();
              return this.isInertia(-1);
            }
          };
          Lethargy2.prototype.isInertia = function(direction) {
            var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
            lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
            if (lastDeltas[0] === null) {
              return direction;
            }
            if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) {
              return false;
            }
            lastDeltasOld = lastDeltas.slice(0, this.stability);
            lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
            oldSum = lastDeltasOld.reduce(function(t, s) {
              return t + s;
            });
            newSum = lastDeltasNew.reduce(function(t, s) {
              return t + s;
            });
            oldAverage = oldSum / lastDeltasOld.length;
            newAverage = newSum / lastDeltasNew.length;
            if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage)) {
              return direction;
            } else {
              return false;
            }
          };
          Lethargy2.prototype.showLastUpDeltas = function() {
            return this.lastUpDeltas;
          };
          Lethargy2.prototype.showLastDownDeltas = function() {
            return this.lastDownDeltas;
          };
          return Lethargy2;
        }();
      }).call(commonjsGlobal);
    });
    support = function getSupport() {
      return {
        hasWheelEvent: "onwheel" in document,
        hasMouseWheelEvent: "onmousewheel" in document,
        hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        hasPointer: !!window.navigator.msPointerEnabled,
        hasKeyDown: "onkeydown" in document,
        isFirefox: navigator.userAgent.indexOf("Firefox") > -1
      };
    }();
    toString = Object.prototype.toString;
    hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    bindallStandalone = function(object) {
      if (!object)
        return console.warn("bindAll requires at least one argument.");
      var functions = Array.prototype.slice.call(arguments, 1);
      if (functions.length === 0) {
        for (var method in object) {
          if (hasOwnProperty$1.call(object, method)) {
            if (typeof object[method] == "function" && toString.call(object[method]) == "[object Function]") {
              functions.push(method);
            }
          }
        }
      }
      for (var i = 0; i < functions.length; i++) {
        var f = functions[i];
        object[f] = bind(object[f], object);
      }
    };
    Lethargy = lethargy.Lethargy;
    EVT_ID = "virtualscroll";
    src = VirtualScroll;
    keyCodes = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32
    };
    VirtualScroll.prototype._notify = function(e) {
      var evt = this._event;
      evt.x += evt.deltaX;
      evt.y += evt.deltaY;
      this._emitter.emit(EVT_ID, {
        x: evt.x,
        y: evt.y,
        deltaX: evt.deltaX,
        deltaY: evt.deltaY,
        originalEvent: e
      });
    };
    VirtualScroll.prototype._onWheel = function(e) {
      var options = this.options;
      if (this._lethargy && this._lethargy.check(e) === false)
        return;
      var evt = this._event;
      evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
      evt.deltaY = e.wheelDeltaY || e.deltaY * -1;
      if (support.isFirefox && e.deltaMode == 1) {
        evt.deltaX *= options.firefoxMultiplier;
        evt.deltaY *= options.firefoxMultiplier;
      }
      evt.deltaX *= options.mouseMultiplier;
      evt.deltaY *= options.mouseMultiplier;
      this._notify(e);
    };
    VirtualScroll.prototype._onMouseWheel = function(e) {
      if (this.options.limitInertia && this._lethargy.check(e) === false)
        return;
      var evt = this._event;
      evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0;
      evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta;
      this._notify(e);
    };
    VirtualScroll.prototype._onTouchStart = function(e) {
      var t = e.targetTouches ? e.targetTouches[0] : e;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
    };
    VirtualScroll.prototype._onTouchMove = function(e) {
      var options = this.options;
      if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) {
        e.preventDefault();
      }
      var evt = this._event;
      var t = e.targetTouches ? e.targetTouches[0] : e;
      evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
      evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
      this._notify(e);
    };
    VirtualScroll.prototype._onKeyDown = function(e) {
      var evt = this._event;
      evt.deltaX = evt.deltaY = 0;
      var windowHeight = window.innerHeight - 40;
      switch (e.keyCode) {
        case keyCodes.LEFT:
        case keyCodes.UP:
          evt.deltaY = this.options.keyStep;
          break;
        case keyCodes.RIGHT:
        case keyCodes.DOWN:
          evt.deltaY = -this.options.keyStep;
          break;
        case e.shiftKey:
          evt.deltaY = windowHeight;
          break;
        case keyCodes.SPACE:
          evt.deltaY = -windowHeight;
          break;
        default:
          return;
      }
      this._notify(e);
    };
    VirtualScroll.prototype._bind = function() {
      if (support.hasWheelEvent)
        this.el.addEventListener("wheel", this._onWheel, this.listenerOptions);
      if (support.hasMouseWheelEvent)
        this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions);
      if (support.hasTouch && this.options.useTouch) {
        this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions);
        this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions);
      }
      if (support.hasPointer && support.hasTouchWin) {
        this.bodyTouchAction = document.body.style.msTouchAction;
        document.body.style.msTouchAction = "none";
        this.el.addEventListener("MSPointerDown", this._onTouchStart, true);
        this.el.addEventListener("MSPointerMove", this._onTouchMove, true);
      }
      if (support.hasKeyDown && this.options.useKeyboard)
        document.addEventListener("keydown", this._onKeyDown);
    };
    VirtualScroll.prototype._unbind = function() {
      if (support.hasWheelEvent)
        this.el.removeEventListener("wheel", this._onWheel);
      if (support.hasMouseWheelEvent)
        this.el.removeEventListener("mousewheel", this._onMouseWheel);
      if (support.hasTouch) {
        this.el.removeEventListener("touchstart", this._onTouchStart);
        this.el.removeEventListener("touchmove", this._onTouchMove);
      }
      if (support.hasPointer && support.hasTouchWin) {
        document.body.style.msTouchAction = this.bodyTouchAction;
        this.el.removeEventListener("MSPointerDown", this._onTouchStart, true);
        this.el.removeEventListener("MSPointerMove", this._onTouchMove, true);
      }
      if (support.hasKeyDown && this.options.useKeyboard)
        document.removeEventListener("keydown", this._onKeyDown);
    };
    VirtualScroll.prototype.on = function(cb, ctx) {
      this._emitter.on(EVT_ID, cb, ctx);
      var events = this._emitter.e;
      if (events && events[EVT_ID] && events[EVT_ID].length === 1)
        this._bind();
    };
    VirtualScroll.prototype.off = function(cb, ctx) {
      this._emitter.off(EVT_ID, cb, ctx);
      var events = this._emitter.e;
      if (!events[EVT_ID] || events[EVT_ID].length <= 0)
        this._unbind();
    };
    VirtualScroll.prototype.reset = function() {
      var evt = this._event;
      evt.x = 0;
      evt.y = 0;
    };
    VirtualScroll.prototype.destroy = function() {
      this._emitter.off();
      this._unbind();
    };
    NEWTON_ITERATIONS = 4;
    NEWTON_MIN_SLOPE = 1e-3;
    SUBDIVISION_PRECISION = 1e-7;
    SUBDIVISION_MAX_ITERATIONS = 10;
    kSplineTableSize = 11;
    kSampleStepSize = 1 / (kSplineTableSize - 1);
    float32ArraySupported = typeof Float32Array === "function";
    src$1 = function bezier(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing(x) {
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };
    keyCodes$1 = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32,
      TAB: 9,
      PAGEUP: 33,
      PAGEDOWN: 34,
      HOME: 36,
      END: 35
    };
    _default$2 = function(_Core) {
      _inherits(_default2, _Core);
      var _super = _createSuper(_default2);
      function _default2() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, _default2);
        if (history.scrollRestoration) {
          history.scrollRestoration = "manual";
        }
        window.scrollTo(0, 0);
        _this = _super.call(this, options);
        if (_this.inertia)
          _this.lerp = _this.inertia * 0.1;
        _this.isScrolling = false;
        _this.isDraggingScrollbar = false;
        _this.isTicking = false;
        _this.hasScrollTicking = false;
        _this.parallaxElements = {};
        _this.stop = false;
        _this.scrollbarContainer = options.scrollbarContainer;
        _this.checkKey = _this.checkKey.bind(_assertThisInitialized(_this));
        window.addEventListener("keydown", _this.checkKey, false);
        return _this;
      }
      _createClass(_default2, [{
        key: "init",
        value: function init() {
          var _this2 = this;
          this.html.classList.add(this.smoothClass);
          this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction);
          this.instance = _objectSpread2({
            delta: {
              x: this.initPosition.x,
              y: this.initPosition.y
            },
            scroll: {
              x: this.initPosition.x,
              y: this.initPosition.y
            }
          }, this.instance);
          this.vs = new src({
            el: this.scrollFromAnywhere ? document : this.el,
            mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : 0.4,
            firefoxMultiplier: this.firefoxMultiplier,
            touchMultiplier: this.touchMultiplier,
            useKeyboard: false,
            passive: true
          });
          this.vs.on(function(e) {
            if (_this2.stop) {
              return;
            }
            if (!_this2.isDraggingScrollbar) {
              requestAnimationFrame(function() {
                _this2.updateDelta(e);
                if (!_this2.isScrolling)
                  _this2.startScrolling();
              });
            }
          });
          this.setScrollLimit();
          this.initScrollBar();
          this.addSections();
          this.addElements();
          this.checkScroll(true);
          this.transformElements(true, true);
          _get(_getPrototypeOf(_default2.prototype), "init", this).call(this);
        }
      }, {
        key: "setScrollLimit",
        value: function setScrollLimit() {
          this.instance.limit.y = this.el.offsetHeight - this.windowHeight;
          if (this.direction === "horizontal") {
            var totalWidth = 0;
            var nodes = this.el.children;
            for (var i = 0; i < nodes.length; i++) {
              totalWidth += nodes[i].offsetWidth;
            }
            this.instance.limit.x = totalWidth - this.windowWidth;
          }
        }
      }, {
        key: "startScrolling",
        value: function startScrolling() {
          this.startScrollTs = Date.now();
          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "stopScrolling",
        value: function stopScrolling() {
          cancelAnimationFrame(this.checkScrollRaf);
          this.startScrollTs = void 0;
          if (this.scrollToRaf) {
            cancelAnimationFrame(this.scrollToRaf);
            this.scrollToRaf = null;
          }
          this.isScrolling = false;
          this.instance.scroll.y = Math.round(this.instance.scroll.y);
          this.html.classList.remove(this.scrollingClass);
        }
      }, {
        key: "checkKey",
        value: function checkKey(e) {
          var _this3 = this;
          if (this.stop) {
            if (e.keyCode == keyCodes$1.TAB) {
              requestAnimationFrame(function() {
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0;
              });
            }
            return;
          }
          switch (e.keyCode) {
            case keyCodes$1.TAB:
              requestAnimationFrame(function() {
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0;
                _this3.scrollTo(document.activeElement, {
                  offset: -window.innerHeight / 2
                });
              });
              break;
            case keyCodes$1.UP:
              if (this.isActiveElementScrollSensitive()) {
                this.instance.delta[this.directionAxis] -= 240;
              }
              break;
            case keyCodes$1.DOWN:
              if (this.isActiveElementScrollSensitive()) {
                this.instance.delta[this.directionAxis] += 240;
              }
              break;
            case keyCodes$1.PAGEUP:
              this.instance.delta[this.directionAxis] -= window.innerHeight;
              break;
            case keyCodes$1.PAGEDOWN:
              this.instance.delta[this.directionAxis] += window.innerHeight;
              break;
            case keyCodes$1.HOME:
              this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.END:
              this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.SPACE:
              if (this.isActiveElementScrollSensitive()) {
                if (e.shiftKey) {
                  this.instance.delta[this.directionAxis] -= window.innerHeight;
                } else {
                  this.instance.delta[this.directionAxis] += window.innerHeight;
                }
              }
              break;
            default:
              return;
          }
          if (this.instance.delta[this.directionAxis] < 0)
            this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis])
            this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
          this.stopScrolling();
          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "isActiveElementScrollSensitive",
        value: function isActiveElementScrollSensitive() {
          return !(document.activeElement instanceof HTMLInputElement) && !(document.activeElement instanceof HTMLTextAreaElement) && !(document.activeElement instanceof HTMLButtonElement) && !(document.activeElement instanceof HTMLSelectElement);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this4 = this;
          var forced = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          if (forced || this.isScrolling || this.isDraggingScrollbar) {
            if (!this.hasScrollTicking) {
              this.checkScrollRaf = requestAnimationFrame(function() {
                return _this4.checkScroll();
              });
              this.hasScrollTicking = true;
            }
            this.updateScroll();
            var distance = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]);
            var timeSinceStart = Date.now() - this.startScrollTs;
            if (!this.animatingScroll && timeSinceStart > 100 && (distance < 0.5 && this.instance.delta[this.directionAxis] != 0 || distance < 0.5 && this.instance.delta[this.directionAxis] == 0)) {
              this.stopScrolling();
            }
            Object.entries(this.sections).forEach(function(_ref) {
              var _ref2 = _slicedToArray(_ref, 2), i = _ref2[0], section = _ref2[1];
              if (section.persistent || _this4.instance.scroll[_this4.directionAxis] > section.offset[_this4.directionAxis] && _this4.instance.scroll[_this4.directionAxis] < section.limit[_this4.directionAxis]) {
                if (_this4.direction === "horizontal") {
                  _this4.transform(section.el, -_this4.instance.scroll[_this4.directionAxis], 0);
                } else {
                  _this4.transform(section.el, 0, -_this4.instance.scroll[_this4.directionAxis]);
                }
                if (!section.inView) {
                  section.inView = true;
                  section.el.style.opacity = 1;
                  section.el.style.pointerEvents = "all";
                  section.el.setAttribute("data-".concat(_this4.name, "-section-inview"), "");
                }
              } else {
                if (section.inView || forced) {
                  section.inView = false;
                  section.el.style.opacity = 0;
                  section.el.style.pointerEvents = "none";
                  section.el.removeAttribute("data-".concat(_this4.name, "-section-inview"));
                }
                _this4.transform(section.el, 0, 0);
              }
            });
            if (this.getDirection) {
              this.addDirection();
            }
            if (this.getSpeed) {
              this.addSpeed();
              this.speedTs = Date.now();
            }
            this.detectElements();
            this.transformElements();
            if (this.hasScrollbar) {
              var scrollBarTranslation = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
              if (this.direction === "horizontal") {
                this.transform(this.scrollbarThumb, scrollBarTranslation, 0);
              } else {
                this.transform(this.scrollbarThumb, 0, scrollBarTranslation);
              }
            }
            _get(_getPrototypeOf(_default2.prototype), "checkScroll", this).call(this);
            this.hasScrollTicking = false;
          }
        }
      }, {
        key: "resize",
        value: function resize() {
          this.windowHeight = window.innerHeight;
          this.windowWidth = window.innerWidth;
          this.checkContext();
          this.windowMiddle = {
            x: this.windowWidth / 2,
            y: this.windowHeight / 2
          };
          this.update();
        }
      }, {
        key: "updateDelta",
        value: function updateDelta(e) {
          var delta;
          var gestureDirection = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
          if (gestureDirection === "both") {
            delta = e.deltaX + e.deltaY;
          } else if (gestureDirection === "vertical") {
            delta = e.deltaY;
          } else if (gestureDirection === "horizontal") {
            delta = e.deltaX;
          } else {
            delta = e.deltaY;
          }
          this.instance.delta[this.directionAxis] -= delta * this.multiplier;
          if (this.instance.delta[this.directionAxis] < 0)
            this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis])
            this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
        }
      }, {
        key: "updateScroll",
        value: function updateScroll(e) {
          if (this.isScrolling || this.isDraggingScrollbar) {
            this.instance.scroll[this.directionAxis] = lerp(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp);
          } else {
            if (this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis]) {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]);
            } else if (this.instance.scroll.y < 0) {
              this.setScroll(this.instance.scroll[this.directionAxis], 0);
            } else {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (this.instance.delta.y > this.instance.scroll.y) {
            if (this.instance.direction !== "down") {
              this.instance.direction = "down";
            }
          } else if (this.instance.delta.y < this.instance.scroll.y) {
            if (this.instance.direction !== "up") {
              this.instance.direction = "up";
            }
          }
          if (this.instance.delta.x > this.instance.scroll.x) {
            if (this.instance.direction !== "right") {
              this.instance.direction = "right";
            }
          } else if (this.instance.delta.x < this.instance.scroll.x) {
            if (this.instance.direction !== "left") {
              this.instance.direction = "left";
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis]) {
            this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "initScrollBar",
        value: function initScrollBar() {
          this.scrollbar = document.createElement("span");
          this.scrollbarThumb = document.createElement("span");
          this.scrollbar.classList.add("".concat(this.scrollbarClass));
          this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb"));
          this.scrollbar.append(this.scrollbarThumb);
          if (this.scrollbarContainer) {
            this.scrollbarContainer.append(this.scrollbar);
          } else {
            document.body.append(this.scrollbar);
          }
          this.getScrollBar = this.getScrollBar.bind(this);
          this.releaseScrollBar = this.releaseScrollBar.bind(this);
          this.moveScrollBar = this.moveScrollBar.bind(this);
          this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar);
          window.addEventListener("mouseup", this.releaseScrollBar);
          window.addEventListener("mousemove", this.moveScrollBar);
          this.hasScrollbar = false;
          if (this.direction == "horizontal") {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === "horizontal") {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "reinitScrollBar",
        value: function reinitScrollBar() {
          this.hasScrollbar = false;
          if (this.direction == "horizontal") {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === "horizontal") {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "destroyScrollBar",
        value: function destroyScrollBar() {
          this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar);
          window.removeEventListener("mouseup", this.releaseScrollBar);
          window.removeEventListener("mousemove", this.moveScrollBar);
          this.scrollbar.remove();
        }
      }, {
        key: "getScrollBar",
        value: function getScrollBar(e) {
          this.isDraggingScrollbar = true;
          this.checkScroll();
          this.html.classList.remove(this.scrollingClass);
          this.html.classList.add(this.draggingClass);
        }
      }, {
        key: "releaseScrollBar",
        value: function releaseScrollBar(e) {
          this.isDraggingScrollbar = false;
          if (this.isScrolling) {
            this.html.classList.add(this.scrollingClass);
          }
          this.html.classList.remove(this.draggingClass);
        }
      }, {
        key: "moveScrollBar",
        value: function moveScrollBar(e) {
          var _this5 = this;
          if (this.isDraggingScrollbar) {
            requestAnimationFrame(function() {
              var x = (e.clientX - _this5.scrollbarBCR.left) * 100 / _this5.scrollbarWidth * _this5.instance.limit.x / 100;
              var y = (e.clientY - _this5.scrollbarBCR.top) * 100 / _this5.scrollbarHeight * _this5.instance.limit.y / 100;
              if (y > 0 && y < _this5.instance.limit.y) {
                _this5.instance.delta.y = y;
              }
              if (x > 0 && x < _this5.instance.limit.x) {
                _this5.instance.delta.x = x;
              }
            });
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this6 = this;
          this.els = {};
          this.parallaxElements = {};
          var els = this.el.querySelectorAll("[data-".concat(this.name, "]"));
          els.forEach(function(el, index) {
            var targetParents = getParents(el);
            var section = Object.entries(_this6.sections).map(function(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], section2 = _ref4[1];
              return section2;
            }).find(function(section2) {
              return targetParents.includes(section2.el);
            });
            var cl = el.dataset[_this6.name + "Class"] || _this6["class"];
            var id = typeof el.dataset[_this6.name + "Id"] === "string" ? el.dataset[_this6.name + "Id"] : "el" + index;
            var top;
            var left;
            var repeat = el.dataset[_this6.name + "Repeat"];
            var call = el.dataset[_this6.name + "Call"];
            var position = el.dataset[_this6.name + "Position"];
            var delay = el.dataset[_this6.name + "Delay"];
            var direction = el.dataset[_this6.name + "Direction"];
            var sticky = typeof el.dataset[_this6.name + "Sticky"] === "string";
            var speed = el.dataset[_this6.name + "Speed"] ? parseFloat(el.dataset[_this6.name + "Speed"]) / 10 : false;
            var offset = typeof el.dataset[_this6.name + "Offset"] === "string" ? el.dataset[_this6.name + "Offset"].split(",") : _this6.offset;
            var target = el.dataset[_this6.name + "Target"];
            var targetEl;
            if (target !== void 0) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            if (section === null) {
              top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;
              left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;
            } else {
              if (!section.inView) {
                top = targetElBCR.top - getTranslate(section.el).y - getTranslate(targetEl).y;
                left = targetElBCR.left - getTranslate(section.el).x - getTranslate(targetEl).x;
              } else {
                top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;
                left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;
              }
            }
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            var middle = {
              x: (right - left) / 2 + left,
              y: (bottom - top) / 2 + top
            };
            if (sticky) {
              var elBCR = el.getBoundingClientRect();
              var elTop = elBCR.top;
              var elLeft = elBCR.left;
              var elDistance = {
                x: elLeft - left,
                y: elTop - top
              };
              top += window.innerHeight;
              left += window.innerWidth;
              bottom = elTop + targetEl.offsetHeight - el.offsetHeight - elDistance[_this6.directionAxis];
              right = elLeft + targetEl.offsetWidth - el.offsetWidth - elDistance[_this6.directionAxis];
              middle = {
                x: (right - left) / 2 + left,
                y: (bottom - top) / 2 + top
              };
            }
            if (repeat == "false") {
              repeat = false;
            } else if (repeat != void 0) {
              repeat = true;
            } else {
              repeat = _this6.repeat;
            }
            var relativeOffset = [0, 0];
            if (offset) {
              if (_this6.direction === "horizontal") {
                for (var i = 0; i < offset.length; i++) {
                  if (typeof offset[i] == "string") {
                    if (offset[i].includes("%")) {
                      relativeOffset[i] = parseInt(offset[i].replace("%", "") * _this6.windowWidth / 100);
                    } else {
                      relativeOffset[i] = parseInt(offset[i]);
                    }
                  } else {
                    relativeOffset[i] = offset[i];
                  }
                }
                left = left + relativeOffset[0];
                right = right - relativeOffset[1];
              } else {
                for (var i = 0; i < offset.length; i++) {
                  if (typeof offset[i] == "string") {
                    if (offset[i].includes("%")) {
                      relativeOffset[i] = parseInt(offset[i].replace("%", "") * _this6.windowHeight / 100);
                    } else {
                      relativeOffset[i] = parseInt(offset[i]);
                    }
                  } else {
                    relativeOffset[i] = offset[i];
                  }
                }
                top = top + relativeOffset[0];
                bottom = bottom - relativeOffset[1];
              }
            }
            var mappedEl = {
              el,
              id,
              "class": cl,
              section,
              top,
              middle,
              bottom,
              left,
              right,
              offset,
              progress: 0,
              repeat,
              inView: false,
              call,
              speed,
              delay,
              position,
              target: targetEl,
              direction,
              sticky
            };
            _this6.els[id] = mappedEl;
            if (el.classList.contains(cl)) {
              _this6.setInView(_this6.els[id], id);
            }
            if (speed !== false || sticky) {
              _this6.parallaxElements[id] = mappedEl;
            }
          });
        }
      }, {
        key: "addSections",
        value: function addSections() {
          var _this7 = this;
          this.sections = {};
          var sections = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
          if (sections.length === 0) {
            sections = [this.el];
          }
          sections.forEach(function(section, index) {
            var id = typeof section.dataset[_this7.name + "Id"] === "string" ? section.dataset[_this7.name + "Id"] : "section" + index;
            var sectionBCR = section.getBoundingClientRect();
            var offset = {
              x: sectionBCR.left - window.innerWidth * 1.5 - getTranslate(section).x,
              y: sectionBCR.top - window.innerHeight * 1.5 - getTranslate(section).y
            };
            var limit = {
              x: offset.x + sectionBCR.width + window.innerWidth * 2,
              y: offset.y + sectionBCR.height + window.innerHeight * 2
            };
            var persistent = typeof section.dataset[_this7.name + "Persistent"] === "string";
            section.setAttribute("data-scroll-section-id", id);
            var mappedSection = {
              el: section,
              offset,
              limit,
              inView: false,
              persistent,
              id
            };
            _this7.sections[id] = mappedSection;
          });
        }
      }, {
        key: "transform",
        value: function transform(element, x, y, delay) {
          var transform2;
          if (!delay) {
            transform2 = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(x, ",").concat(y, ",0,1)");
          } else {
            var start = getTranslate(element);
            var lerpX = lerp(start.x, x, delay);
            var lerpY = lerp(start.y, y, delay);
            transform2 = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(lerpX, ",").concat(lerpY, ",0,1)");
          }
          element.style.webkitTransform = transform2;
          element.style.msTransform = transform2;
          element.style.transform = transform2;
        }
      }, {
        key: "transformElements",
        value: function transformElements(isForced) {
          var _this8 = this;
          var setAllElements = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var scrollRight = this.instance.scroll.x + this.windowWidth;
          var scrollBottom = this.instance.scroll.y + this.windowHeight;
          var scrollMiddle = {
            x: this.instance.scroll.x + this.windowMiddle.x,
            y: this.instance.scroll.y + this.windowMiddle.y
          };
          Object.entries(this.parallaxElements).forEach(function(_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2), i = _ref6[0], current = _ref6[1];
            var transformDistance = false;
            if (isForced) {
              transformDistance = 0;
            }
            if (current.inView || setAllElements) {
              switch (current.position) {
                case "top":
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case "elementTop":
                  transformDistance = (scrollBottom - current.top) * -current.speed;
                  break;
                case "bottom":
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollBottom + _this8.windowHeight) * current.speed;
                  break;
                case "left":
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case "elementLeft":
                  transformDistance = (scrollRight - current.left) * -current.speed;
                  break;
                case "right":
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollRight + _this8.windowHeight) * current.speed;
                  break;
                default:
                  transformDistance = (scrollMiddle[_this8.directionAxis] - current.middle[_this8.directionAxis]) * -current.speed;
                  break;
              }
            }
            if (current.sticky) {
              if (current.inView) {
                if (_this8.direction === "horizontal") {
                  transformDistance = _this8.instance.scroll.x - current.left + window.innerWidth;
                } else {
                  transformDistance = _this8.instance.scroll.y - current.top + window.innerHeight;
                }
              } else {
                if (_this8.direction === "horizontal") {
                  if (_this8.instance.scroll.x < current.left - window.innerWidth && _this8.instance.scroll.x < current.left - window.innerWidth / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.x > current.right && _this8.instance.scroll.x > current.right + 100) {
                    transformDistance = current.right - current.left + window.innerWidth;
                  } else {
                    transformDistance = false;
                  }
                } else {
                  if (_this8.instance.scroll.y < current.top - window.innerHeight && _this8.instance.scroll.y < current.top - window.innerHeight / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.y > current.bottom && _this8.instance.scroll.y > current.bottom + 100) {
                    transformDistance = current.bottom - current.top + window.innerHeight;
                  } else {
                    transformDistance = false;
                  }
                }
              }
            }
            if (transformDistance !== false) {
              if (current.direction === "horizontal" || _this8.direction === "horizontal" && current.direction !== "vertical") {
                _this8.transform(current.el, transformDistance, 0, isForced ? false : current.delay);
              } else {
                _this8.transform(current.el, 0, transformDistance, isForced ? false : current.delay);
              }
            }
          });
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var _this9 = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var offset = parseInt(options.offset) || 0;
          var duration = !isNaN(parseInt(options.duration)) ? parseInt(options.duration) : 1e3;
          var easing = options.easing || [0.25, 0, 0.35, 1];
          var disableLerp = options.disableLerp ? true : false;
          var callback = options.callback ? options.callback : false;
          easing = src$1.apply(void 0, _toConsumableArray(easing));
          if (typeof target === "string") {
            if (target === "top") {
              target = 0;
            } else if (target === "bottom") {
              target = this.instance.limit.y;
            } else if (target === "left") {
              target = 0;
            } else if (target === "right") {
              target = this.instance.limit.x;
            } else {
              target = document.querySelector(target);
              if (!target) {
                return;
              }
            }
          } else if (typeof target === "number") {
            target = parseInt(target);
          } else if (target && target.tagName)
            ;
          else {
            console.warn("`target` parameter is not valid");
            return;
          }
          if (typeof target !== "number") {
            var targetInScope = getParents(target).includes(this.el);
            if (!targetInScope) {
              return;
            }
            var targetBCR = target.getBoundingClientRect();
            var offsetTop = targetBCR.top;
            var offsetLeft = targetBCR.left;
            var targetParents = getParents(target);
            var parentSection = targetParents.find(function(candidate) {
              return Object.entries(_this9.sections).map(function(_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2), key = _ref8[0], section = _ref8[1];
                return section;
              }).find(function(section) {
                return section.el == candidate;
              });
            });
            var parentSectionOffset = 0;
            if (parentSection) {
              parentSectionOffset = getTranslate(parentSection)[this.directionAxis];
            } else {
              parentSectionOffset = -this.instance.scroll[this.directionAxis];
            }
            if (this.direction === "horizontal") {
              offset = offsetLeft + offset - parentSectionOffset;
            } else {
              offset = offsetTop + offset - parentSectionOffset;
            }
          } else {
            offset = target + offset;
          }
          var scrollStart = parseFloat(this.instance.delta[this.directionAxis]);
          var scrollTarget = Math.max(0, Math.min(offset, this.instance.limit[this.directionAxis]));
          var scrollDiff = scrollTarget - scrollStart;
          var render = function render2(p) {
            if (disableLerp) {
              if (_this9.direction === "horizontal") {
                _this9.setScroll(scrollStart + scrollDiff * p, _this9.instance.delta.y);
              } else {
                _this9.setScroll(_this9.instance.delta.x, scrollStart + scrollDiff * p);
              }
            } else {
              _this9.instance.delta[_this9.directionAxis] = scrollStart + scrollDiff * p;
            }
          };
          this.animatingScroll = true;
          this.stopScrolling();
          this.startScrolling();
          var start = Date.now();
          var loop = function loop2() {
            var p = (Date.now() - start) / duration;
            if (p > 1) {
              render(1);
              _this9.animatingScroll = false;
              if (duration == 0)
                _this9.update();
              if (callback)
                callback();
            } else {
              _this9.scrollToRaf = requestAnimationFrame(loop2);
              render(easing(p));
            }
          };
          loop();
        }
      }, {
        key: "update",
        value: function update() {
          this.setScrollLimit();
          this.addSections();
          this.addElements();
          this.detectElements();
          this.updateScroll();
          this.transformElements(true);
          this.reinitScrollBar();
          this.checkScroll(true);
        }
      }, {
        key: "startScroll",
        value: function startScroll() {
          this.stop = false;
        }
      }, {
        key: "stopScroll",
        value: function stopScroll() {
          this.stop = true;
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance = _objectSpread2(_objectSpread2({}, this.instance), {}, {
            scroll: {
              x,
              y
            },
            delta: {
              x,
              y
            },
            speed: 0
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(_default2.prototype), "destroy", this).call(this);
          this.stopScrolling();
          this.html.classList.remove(this.smoothClass);
          this.vs.destroy();
          this.destroyScrollBar();
          window.removeEventListener("keydown", this.checkKey, false);
        }
      }]);
      return _default2;
    }(_default);
    Smooth = function() {
      function Smooth2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Smooth2);
        this.options = options;
        Object.assign(this, defaults, options);
        this.smartphone = defaults.smartphone;
        if (options.smartphone)
          Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults.tablet;
        if (options.tablet)
          Object.assign(this.tablet, options.tablet);
        if (!this.smooth && this.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible");
        if (!this.tablet.smooth && this.tablet.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible (tablet)");
        if (!this.smartphone.smooth && this.smartphone.direction == "horizontal")
          console.warn("\u{1F6A8} `smooth:false` & `horizontal` direction are not yet compatible (smartphone)");
        this.init();
      }
      _createClass(Smooth2, [{
        key: "init",
        value: function init() {
          this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint;
          this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint;
          if (this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet) {
            this.scroll = new _default$2(this.options);
          } else {
            this.scroll = new _default$1(this.options);
          }
          this.scroll.init();
          if (window.location.hash) {
            var id = window.location.hash.slice(1, window.location.hash.length);
            var target = document.getElementById(id);
            if (target)
              this.scroll.scrollTo(target);
          }
        }
      }, {
        key: "update",
        value: function update() {
          this.scroll.update();
        }
      }, {
        key: "start",
        value: function start() {
          this.scroll.startScroll();
        }
      }, {
        key: "stop",
        value: function stop() {
          this.scroll.stopScroll();
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target, options) {
          this.scroll.scrollTo(target, options);
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.scroll.setScroll(x, y);
        }
      }, {
        key: "on",
        value: function on(event, func) {
          this.scroll.setEvents(event, func);
        }
      }, {
        key: "off",
        value: function off(event, func) {
          this.scroll.unsetEvents(event, func);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.scroll.destroy();
        }
      }]);
      return Smooth2;
    }();
    Native = function() {
      function Native2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Native2);
        this.options = options;
        Object.assign(this, defaults, options);
        this.smartphone = defaults.smartphone;
        if (options.smartphone)
          Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults.tablet;
        if (options.tablet)
          Object.assign(this.tablet, options.tablet);
        this.init();
      }
      _createClass(Native2, [{
        key: "init",
        value: function init() {
          this.scroll = new _default$1(this.options);
          this.scroll.init();
          if (window.location.hash) {
            var id = window.location.hash.slice(1, window.location.hash.length);
            var target = document.getElementById(id);
            if (target)
              this.scroll.scrollTo(target);
          }
        }
      }, {
        key: "update",
        value: function update() {
          this.scroll.update();
        }
      }, {
        key: "start",
        value: function start() {
          this.scroll.startScroll();
        }
      }, {
        key: "stop",
        value: function stop() {
          this.scroll.stopScroll();
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target, options) {
          this.scroll.scrollTo(target, options);
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.scroll.setScroll(x, y);
        }
      }, {
        key: "on",
        value: function on(event, func) {
          this.scroll.setEvents(event, func);
        }
      }, {
        key: "off",
        value: function off(event, func) {
          this.scroll.unsetEvents(event, func);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.scroll.destroy();
        }
      }]);
      return Native2;
    }();
    locomotive_scroll_esm_default = Smooth;
  }
});

// node_modules/react-locomotive-scroll/module/LocomotiveScroll.context.js
var require_LocomotiveScroll_context = __commonJS({
  "node_modules/react-locomotive-scroll/module/LocomotiveScroll.context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocomotiveScrollProvider = exports.LocomotiveScrollContext = void 0;
    var tslib_1 = require_tslib();
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var use_debounce_1 = require_lib();
    var use_resize_observer_1 = tslib_1.__importDefault((init_bundle_esm(), __toCommonJS(bundle_esm_exports)));
    exports.LocomotiveScrollContext = (0, react_1.createContext)({
      scroll: null,
      isReady: false
    });
    function LocomotiveScrollProvider({ children, options, containerRef, watch, onUpdate, location, onLocationChange }) {
      const { height: containerHeight } = (0, use_resize_observer_1.default)({ ref: containerRef });
      const [isReady, setIsReady] = (0, react_1.useState)(false);
      const LocomotiveScrollRef = (0, react_1.useRef)(null);
      const [height] = (0, use_debounce_1.useDebounce)(containerHeight, 100);
      if (!watch) {
        console.warn("react-locomotive-scroll: you did not add any props to watch. Scroll may have weird behaviours if the instance is not updated when the route changes");
      }
      (0, react_1.useEffect)(() => {
        ;
        (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const LocomotiveScroll = (yield Promise.resolve().then(() => tslib_1.__importStar((init_locomotive_scroll_esm(), __toCommonJS(locomotive_scroll_esm_exports))))).default;
            const dataScrollContainer = document.querySelector("[data-scroll-container]");
            if (!dataScrollContainer) {
              console.warn(`react-locomotive-scroll: [data-scroll-container] dataset was not found. You likely forgot to add it which will prevent Locomotive Scroll to work.`);
            }
            LocomotiveScrollRef.current = new LocomotiveScroll(Object.assign({ el: dataScrollContainer !== null && dataScrollContainer !== void 0 ? dataScrollContainer : void 0 }, options));
            setIsReady(true);
          } catch (error) {
            throw Error(`react-locomotive-scroll: ${error}`);
          }
        }))();
        return () => {
          var _a;
          (_a = LocomotiveScrollRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
          setIsReady(false);
        };
      }, []);
      (0, react_1.useEffect)(() => {
        if (!LocomotiveScrollRef.current) {
          return;
        }
        LocomotiveScrollRef.current.update();
        if (onUpdate) {
          onUpdate(LocomotiveScrollRef.current);
        }
      }, watch ? [...watch, height] : [height]);
      (0, react_1.useEffect)(() => {
        if (!LocomotiveScrollRef.current || !location) {
          return;
        }
        LocomotiveScrollRef.current.update();
        if (onLocationChange) {
          onLocationChange(LocomotiveScrollRef.current);
        }
      }, [location]);
      return (0, jsx_runtime_1.jsx)(exports.LocomotiveScrollContext.Provider, Object.assign({ value: { scroll: LocomotiveScrollRef.current, isReady } }, { children }));
    }
    exports.LocomotiveScrollProvider = LocomotiveScrollProvider;
    exports.LocomotiveScrollContext.displayName = "LocomotiveScrollContext";
    LocomotiveScrollProvider.displayName = "LocomotiveScrollProvider";
  }
});

// node_modules/react-locomotive-scroll/module/useLocomotiveScroll.hook.js
var require_useLocomotiveScroll_hook = __commonJS({
  "node_modules/react-locomotive-scroll/module/useLocomotiveScroll.hook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useLocomotiveScroll = void 0;
    var react_1 = require_react();
    var LocomotiveScroll_context_1 = require_LocomotiveScroll_context();
    function useLocomotiveScroll() {
      const context = (0, react_1.useContext)(LocomotiveScroll_context_1.LocomotiveScrollContext);
      if (context === void 0) {
        console.warn("react-locomotive-scroll: the context is missing. You may be using the hook without registering LocomotiveScrollProvider, or you may be using the hook in a component which is not wrapped by LocomotiveScrollProvider.");
      }
      return context;
    }
    exports.useLocomotiveScroll = useLocomotiveScroll;
    useLocomotiveScroll.displayName = "useLocomotiveScroll";
  }
});

// node_modules/react-locomotive-scroll/module/index.js
var require_module = __commonJS({
  "node_modules/react-locomotive-scroll/module/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useLocomotiveScroll = exports.LocomotiveScrollProvider = exports.LocomotiveScrollContext = void 0;
    var LocomotiveScroll_context_1 = require_LocomotiveScroll_context();
    Object.defineProperty(exports, "LocomotiveScrollContext", { enumerable: true, get: function() {
      return LocomotiveScroll_context_1.LocomotiveScrollContext;
    } });
    Object.defineProperty(exports, "LocomotiveScrollProvider", { enumerable: true, get: function() {
      return LocomotiveScroll_context_1.LocomotiveScrollProvider;
    } });
    var useLocomotiveScroll_hook_1 = require_useLocomotiveScroll_hook();
    Object.defineProperty(exports, "useLocomotiveScroll", { enumerable: true, get: function() {
      return useLocomotiveScroll_hook_1.useLocomotiveScroll;
    } });
  }
});
export default require_module();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
//# sourceMappingURL=react-locomotive-scroll.js.map
